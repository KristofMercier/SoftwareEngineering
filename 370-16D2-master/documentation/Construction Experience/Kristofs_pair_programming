Pair programming
Kristof Mercier programming with Sam Horvatin
    25/11/2016 @ 1:00PM - 3:30pm

	During this seesion we focused on implementing parts of the Interpreter and IntepreterFunctions which deal with storing Forth variables and mapping Forth Words to internal command within the interpreterFunctions class. We also implemented and reviewed some of the individual functions within the InterpreterFunctions class. The session went fairly well and we got through a fairly tricky implementation decision, storing known ForthWords in a dictionary, with relative ease. While we were still trying to conceptualize the full impact of this implementation decision, I noticed that I could focus on thinking from a higher abstraction, as I could rely on Sam to deal with the lower level. In the time that I spent figuring out how the flow of the system would benefit, he was considering how to load the dictionary at the beginning of the program's execution. For this instance I think that pair programming was a valueable asset, though I gained insight as to its drawback as well. As I had been previously implementing other parts of the interpreter, I had more knowledge of the subsystem coming in, which required for us to take some time to get Sam caught up. It would almost always be the case where one of the programmers has more experience in an area than the other, and this could be a considerable drawback in situations where this difference in understanding is more significant. Overall I would conclude that the session was a success, though I would not consider pair programming a practical method in all situations.



Pair programming
Kristof Mercier programming with Chris Mykota-Reid
    26/11/2016 @ 9:00PM - 11:10pm

	At this point, the Interpreter implementation was entirely planned out, if not implemented, with the exception of the conditional and loop functionality. This was one of the most difficult parts of the interpreter, and though we did not finish its implementation within the session, we planned out how it was to be done, making further implemenation fairly simple. We ended up deciding on keeping stacks for each type of loop and if-statement, which held all of the necessary information for the loop or conditionals execution. This ended up being an efficient solution for a variety of resons, and pair programming effectively streamlined the decision making process. Seeing as I was the one who had implemented almost the entire interpreter coming in, it was more difficult to get Chris caught up on the implementation details. This drawback was fairly insignificant, as most of the discussion was conceptual, and I could fill in the more specific implementation details on the way. I have always felt that explaining one's thinking forces one to consider the concept more succinctly and this is something that pair programming allows for. I think that if we had designed the implementation of the entire system in such a way as to minimize the difference in knowledge of the pairs, the process would have been more efficient. The group all had an overall understanding of each class from the design document, which held fairly well, but having implemented part of the component will always yield a greater understanding. In the future I would design the construction phase with this in mind, ensuring more efficient pair programming. In conclusion, this session was useful and allowed us to efficiently make important decisions about the implementation, though I feel that designing a construction phase oriented around pair programming would make the process more effective.